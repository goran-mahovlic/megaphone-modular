// Load HAL
#include "includes.h"

#include "records.h"
#include "contacts.h"
#include "index.h"
#include "search.h"
#include "sms.h"

/*
  Read the contacts and message stream generated by the stim, and put
  it all into to the D81s for the phone state.

  Linux only for testing for now.
  But it could later become part of a native backup and restore facility.
*/

void usage(void)
{
  fprintf(stderr,"usage: stim-import <stim_file.txt>\n");
  exit(-1);
}

int main(int argc,char **argv)
{
  if (argc!=2) {
    usage();
  }
  
  FILE *f=fopen(argv[1],"rb");
  
  hal_init();
  mega65_chdir("PHONE");

  char line[1024];

  // Fields for contacts
  unsigned char firstName[1024];
  unsigned char lastName[1024];
  unsigned char phoneNumber[1024];
  unsigned int unreadCount=0;
  
  // Fields for messages
  unsigned long timestampAztecTime;
  unsigned char messageBody[1024];

  unsigned char contact_added = 0;
  
  line[0]=0; fgets(line,1024,f);
  while(line[0]) {
    // CONTACT:+99920915060:Jerry:Williams:[unread count]:
    unreadCount=0;

    if (sscanf(line,"CONTACT:%[^:]:%[^:]:%[^:]:%d",
	       phoneNumber,firstName,lastName,&unreadCount)>=3) {
      // Found a contact.
      unsigned char buffer[RECORD_DATA_SIZE];
      unsigned int bytes_used=0;

      contact_added = 1;
      
      if (build_contact(buffer,&bytes_used,
			firstName,lastName,phoneNumber,unreadCount)) {
	fprintf(stderr,"ERROR: Failed to parse contact line: %s\n",line);
      } else {	
	
	mega65_cdroot();
	mega65_chdir("PHONE");
	mount_d81("CONTACT0.D81",0);
	read_sector(0,1,0);
	unsigned int record_number = record_allocate_next( (unsigned char *)SECTOR_BUFFER_ADDRESS );
	if (!record_number) {
	  fprintf(stderr,"ERROR: Failed to allocate contact record for: %s\n",line);
	} else {
	  // Write back updated BAM
	  write_sector(0,1,0);

	  // Set record number bytes in record
	  buffer[0]=record_number & 0xff;
	  buffer[1]=record_number >> 8;
	  
	  // Allocated record, so write contact	  
	  char r=write_record_by_id(0,record_number,buffer);
	  if (r) {
	    fprintf(stderr,"ERROR: Failed to write contact to record #%d (code %d)\n",record_number,r);
	  } else {
	    fprintf(stderr,"INFO: Imported contact #%d\n",record_number);
	  }
	}
      }   
    }
    // MESSAGERX:+99973014512:397831207:ü§£üéßüê®üíªü•≠ Id nisi MEGA65 corrupti natus:
    else if (sscanf(line,"MESSAGERX:%[^:]:%ld:%[^:]:",phoneNumber,&timestampAztecTime,messageBody)==3) {

      if (contact_added) {
	// Update search index for contacts
	fprintf(stderr,"INFO: Rebuilding contact index before importing next SMS\n");
	contacts_reindex(0);
      }
      contact_added=0;
      
      sms_log(phoneNumber,timestampAztecTime,messageBody,SMS_DIRECTION_RX);
    }
    // MESSAGETX:+99966049372:397833622:üç≥üçø Quasi nisi quidem, quis veniam sed numquam ipsam quo hic amet molestiae? Veritatis cupiditate ullam nihil et tenetur doloribus, accusantium:
    else if (sscanf(line,"MESSAGETX:%[^:]:%ld:%[^:]:",phoneNumber,&timestampAztecTime,messageBody)==3) {
      // As for MESSAGERX, but don't increment unread message count.
      if (contact_added) {
	// Update search index for contacts
	fprintf(stderr,"INFO: Rebuilding contact index before importing next SMS\n");
	contacts_reindex(0);
      }
      contact_added=0;      

      sms_log(phoneNumber,timestampAztecTime,messageBody,SMS_DIRECTION_TX);
    } else {
      fprintf(stderr,"ERROR: Could not scan line: %s\n",line);
      exit(-1);
    }
    
    line[0]=0; fgets(line,1024,f);
  }

  // Update sorted versions of contacts
  mega65_cdroot();
  mega65_chdir("PHONE");
  
  if (sort_d81("CONTACT0.D81","SORT02-0.D81",0x02)) {
    fprintf(stderr,"FATAL: Failed to sort CONTACT0 by first name\n");
    exit(-1);
  }
  if (sort_d81("CONTACT0.D81","SORT04-0.D81",0x04)) {
    fprintf(stderr,"FATAL: Failed to sort CONTACT0 by last name\n");
    exit(-1);
  }
  if (sort_d81("CONTACT0.D81","SORT06-0.D81",0x06)) {
    fprintf(stderr,"FATAL: Failed to sort CONTACT0 by phone number\n");
    exit(-1);
  }
  
  // Update search index for contacts
  contacts_reindex(0);
}
